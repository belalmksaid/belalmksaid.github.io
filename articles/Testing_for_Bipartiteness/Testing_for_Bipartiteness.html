<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=ox6JKEaIWrNx0BNQrcMDETaUrQ9zml6sEw2UQnayyNBppsVrcRg9Ib05nPCShPM-');ol{margin:0;padding:0}table td,table th{padding:0}.c21{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#434343;border-left-style:solid;border-bottom-width:0pt;width:540pt;border-top-color:#000000;border-bottom-style:solid}.c32{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#999999;border-top-width:0pt;border-right-width:0pt;border-left-color:#999999;vertical-align:top;border-right-color:#999999;border-left-width:0pt;border-top-style:solid;background-color:#434343;border-left-style:solid;border-bottom-width:0pt;width:540pt;border-top-color:#999999;border-bottom-style:solid}.c29{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:201pt;border-top-color:#000000;border-bottom-style:solid}.c28{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:middle;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:71.2pt;border-top-color:#000000;border-bottom-style:solid}.c22{border-right-style:solid;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:195.8pt;border-top-color:#000000;border-bottom-style:solid}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c1{color:#d4d4d4;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.5pt;font-family:"Courier New";font-style:normal}.c12{color:#569cd6;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.5pt;font-family:"Courier New";font-style:normal}.c8{padding-top:0pt;text-indent:36pt;padding-bottom:0pt;line-height:1.25;orphans:2;widows:2;text-align:left}.c30{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c9{padding-top:0pt;padding-bottom:0pt;line-height:1.25;orphans:2;widows:2;text-align:center}.c10{padding-top:0pt;padding-bottom:0pt;line-height:1.25;orphans:2;widows:2;text-align:left}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.3571428571428572;text-align:left;height:11pt}.c14{font-size:10.5pt;font-family:"Courier New";color:#569cd6;font-weight:400}.c3{font-size:10.5pt;font-family:"Courier New";color:#c586c0;font-weight:400}.c17{font-size:10.5pt;font-family:"Courier New";color:#4ec9b0;font-weight:400}.c11{font-size:10.5pt;font-family:"Courier New";color:#9cdcfe;font-weight:400}.c15{border-spacing:0;border-collapse:collapse;margin-right:auto}.c7{color:#000000;text-decoration:none;vertical-align:baseline;font-style:normal}.c6{font-size:10.5pt;font-family:"Courier New";color:#d4d4d4;font-weight:400}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.3571428571428572;text-align:left}.c20{font-size:10.5pt;font-family:"Courier New";color:#dcdcaa;font-weight:400}.c13{font-size:10.5pt;font-family:"Courier New";color:#ce9178;font-weight:400}.c33{margin-left:auto;border-spacing:0;border-collapse:collapse;margin-right:auto}.c31{text-decoration:none;vertical-align:baseline;font-style:normal}.c27{font-weight:400;font-size:14pt;font-family:"Cambria"}.c25{background-color:#ffffff;max-width:540pt;padding:72pt 36pt 72pt 36pt}.c18{font-size:12pt;font-family:"Alegreya";font-weight:400}.c5{font-size:12pt;font-family:"Cambria";font-weight:400}.c26{font-weight:700;font-size:24pt;font-family:"Cambria"}.c34{color:#1155cc;text-decoration:underline}.c24{color:inherit;text-decoration:inherit}.c16{font-style:italic}.c23{height:0pt}.c19{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c25"><p class="c9"><span class="c7 c26">Testing for Bipartiteness in a Graph</span></p><p class="c9 c19"><span class="c7 c27"></span></p><p class="c10"><span class="c27">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c7 c5">Let&rsquo;s say you&rsquo;re an orientation leader at Rutgers University; you take your job very seriously and know that the some of students know each other. You want to split the students into two groups for ice breakers such that none of the people in the two groups know each other. First, do you even know if you could split them? </span></p><p class="c8 c19"><span class="c7 c5"></span></p><p class="c8"><span class="c5">If you think of the students as nodes and their connections with their friends as undirected edges, we can represent the students using a graph. A graph where nodes can be split into two groups such that the nodes are not connected to each is called a </span><span class="c5 c16">bipartite graph</span><span class="c7 c5">. This article will only cover testing for bipartiteness but not grouping nodes into two groups.</span></p><a id="t.4ddb8f843d82ffd23098bf8aea89b4b1c103b929"></a><a id="t.0"></a><table class="c33"><tbody><tr class="c23"><td class="c22" colspan="1" rowspan="1"><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 226.66px; height: 223.50px;"><img alt="" src="images/image2.png" style="width: 226.66px; height: 223.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c28" colspan="1" rowspan="1"><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 75.00px; height: 50.60px;"><img alt="" src="images/image1.png" style="width: 75.00px; height: 50.60px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 205.08px; height: 200.50px;"><img alt="" src="images/image3.png" style="width: 205.08px; height: 200.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></tbody></table><p class="c8"><span class="c5">So how would we do it? Especially, how would we do it in </span><span class="c18">O(|V| + |E|)</span><span class="c5">? Well, there are two traversal algorithms that could traverse a graph in </span><span class="c18">O(|V| + |E|)</span><span class="c7 c5">: BFS and DFS. If you notice, any two students who are connected are put into the two different groups, and the only way there is a conflict in the placement is if there is a cycle in the graph .</span></p><p class="c10 c19"><span class="c7 c5"></span></p><p class="c10"><span class="c7 c5">First, let&rsquo;s create a simple adjacency list based graph:</span></p><a id="t.8452895494d59e6b0810148d92686e56cd79034c"></a><a id="t.1"></a><table class="c15"><tbody><tr class="c23"><td class="c21" colspan="1" rowspan="1"><p class="c2"><span class="c14">class</span><span class="c6">&nbsp;</span><span class="c17">node</span><span class="c1">:</span></p><p class="c2"><span class="c6">&nbsp; &nbsp;</span><span class="c14">def</span><span class="c6">&nbsp;</span><span class="c20">__init__</span><span class="c6">(</span><span class="c11">self</span><span class="c6">, </span><span class="c11">name</span><span class="c1">):</span></p><p class="c2"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c14">self</span><span class="c1">.nodes = []</span></p><p class="c2"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c14">self</span><span class="c6">.color = </span><span class="c13 c31">&#39;white&#39;</span></p><p class="c2"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c14">self</span><span class="c1">.name = name</span></p><p class="c2"><span class="c1">&nbsp; </span></p><p class="c2"><span class="c6">&nbsp; &nbsp;</span><span class="c14">def</span><span class="c6">&nbsp;</span><span class="c20">add</span><span class="c6">(</span><span class="c11">self</span><span class="c6">, </span><span class="c11">neigh</span><span class="c1">):</span></p><p class="c2"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c14">self</span><span class="c1">.nodes.append(neigh)</span></p><p class="c2"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp;neigh.nodes.append(</span><span class="c14">self</span><span class="c1">)</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c14">class</span><span class="c6">&nbsp;</span><span class="c17">graph</span><span class="c1">:</span></p><p class="c2"><span class="c6">&nbsp; &nbsp;</span><span class="c14">def</span><span class="c6">&nbsp;</span><span class="c20">__init__</span><span class="c6">(</span><span class="c11">self</span><span class="c1">):</span></p><p class="c2"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c14">self</span><span class="c1">.nodes = []</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c6">&nbsp; &nbsp;</span><span class="c14">def</span><span class="c6">&nbsp;</span><span class="c20">add</span><span class="c6">(</span><span class="c11">self</span><span class="c6">, </span><span class="c11">node</span><span class="c1">):</span></p><p class="c2"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c14">self</span><span class="c6">.nodes.append(node)</span></p></td></tr></tbody></table><p class="c10 c19"><span class="c7 c5"></span></p><p class="c10"><span class="c7 c5">And let&rsquo;s create the friend graph:</span></p><a id="t.d4510a0e286f3c13565ad8ddb58a09280b96cf18"></a><a id="t.2"></a><table class="c15"><tbody><tr class="c23"><td class="c21" colspan="1" rowspan="1"><p class="c2"><span class="c1">friends = graph()</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c6">mike = node(</span><span class="c13">&#39;Michael&#39;</span><span class="c1">)</span></p><p class="c2"><span class="c6">emily = node(</span><span class="c13">&#39;Emily&#39;</span><span class="c1">)</span></p><p class="c2"><span class="c6">sahl = node(</span><span class="c13">&#39;Sahl&#39;</span><span class="c1">)</span></p><p class="c2"><span class="c6">arielle = node(</span><span class="c13">&#39;Arielle&#39;</span><span class="c1">)</span></p><p class="c2"><span class="c6">nick = node(</span><span class="c13">&#39;Nick&#39;</span><span class="c1">)</span></p><p class="c2"><span class="c6">sakib = node(</span><span class="c13">&#39;Sakib&#39;</span><span class="c1">)</span></p><p class="c2"><span class="c6">david = node(</span><span class="c13">&#39;David&#39;</span><span class="c1">)</span></p><p class="c2"><span class="c6">brian = node(</span><span class="c13">&#39;Brian&#39;</span><span class="c1">)</span></p><p class="c2"><span class="c6">aakash = node(</span><span class="c13">&#39;Aakash&#39;</span><span class="c1">)</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">mike.add(david)</span></p><p class="c2"><span class="c1">mike.add(aakash)</span></p><p class="c2"><span class="c1">aakash.add(nick)</span></p><p class="c2"><span class="c1">nick.add(sakib)</span></p><p class="c2"><span class="c1">sakib.add(emily)</span></p><p class="c2"><span class="c1">sakib.add(sahl)</span></p><p class="c2"><span class="c1">sahl.add(brian)</span></p><p class="c2"><span class="c1">brian.add(arielle)</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c6">friends.add(sakib)</span></p></td></tr></tbody></table><p class="c10"><span class="c7 c5">Notice that this graph contains one island so only node needs to be added to the graph.</span></p><p class="c10 c19"><span class="c7 c5"></span></p><p class="c10"><span class="c7 c5">The algorithm does a simple BFS traversal of the graph, but no need to keep track of visited nodes in a separate data structure since each node has a color tag.</span></p><a id="t.e53afd6af0d20c19b26c4165edc5403d9980586d"></a><a id="t.3"></a><table class="c15"><tbody><tr class="c23"><td class="c32" colspan="1" rowspan="1"><p class="c2"><span class="c3">import</span><span class="c6">&nbsp;queue</span></p><p class="c0"><span class="c12"></span></p><p class="c2"><span class="c14">def</span><span class="c6">&nbsp;</span><span class="c20">switch</span><span class="c6">(</span><span class="c11">color</span><span class="c1">):</span></p><p class="c2"><span class="c6">&nbsp; &nbsp;</span><span class="c3">if</span><span class="c6">&nbsp;color == </span><span class="c13">&#39;red&#39;</span><span class="c1">:</span></p><p class="c2"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c6">&nbsp;</span><span class="c13 c31">&#39;black&#39;</span></p><p class="c2"><span class="c6">&nbsp; &nbsp;</span><span class="c3">return</span><span class="c6">&nbsp;</span><span class="c13">&#39;red&#39;</span></p><p class="c0"><span class="c12"></span></p><p class="c2"><span class="c14">def</span><span class="c6">&nbsp;</span><span class="c20">can_split</span><span class="c6">(</span><span class="c11">graph</span><span class="c1">):</span></p><p class="c2"><span class="c1">&nbsp; &nbsp;qu = queue.Queue()</span></p><p class="c2"><span class="c6">&nbsp; &nbsp;color = </span><span class="c13 c31">&#39;red&#39;</span></p><p class="c2"><span class="c6">&nbsp; &nbsp;</span><span class="c3">for</span><span class="c6">&nbsp;node </span><span class="c14">in</span><span class="c1">&nbsp;graph.nodes:</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;node.color = color</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;color = switch(color)</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;qu.put(node)</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c6">&nbsp; &nbsp;</span><span class="c3">while</span><span class="c6">&nbsp;</span><span class="c14">not</span><span class="c1">&nbsp;qu.empty():</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;node = qu.get()</span></p><p class="c2"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c6">&nbsp;n </span><span class="c14">in</span><span class="c1">&nbsp;node.nodes:</span></p><p class="c2"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c6">&nbsp;n.color == </span><span class="c13">&#39;white&#39;</span><span class="c1">:</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n.color = switch(node.color)</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;qu.put(n)</span></p><p class="c2"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">elif</span><span class="c1">&nbsp;n.color == node.color:</span></p><p class="c2"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c6">&nbsp;</span><span class="c12">False</span></p><p class="c0"><span class="c12"></span></p><p class="c2"><span class="c6">&nbsp; &nbsp;</span><span class="c3">return</span><span class="c6">&nbsp;</span><span class="c14">True</span></p></td></tr></tbody></table><p class="c4"><span class="c7 c5"></span></p><p class="c4"><span class="c7 c5"></span></p><p class="c30"><span class="c5 c34"><a class="c24" href="https://www.google.com/url?q=https://github.com/belalmksaid/MISC/blob/master/graphbip.py&amp;sa=D&amp;ust=1511135272951000&amp;usg=AFQjCNGYPnh4-xy2xZ72BgkZMTGZcpIKrg">Here</a></span><span class="c7 c5">&nbsp;is the full code.</span></p></body></html>